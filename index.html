#include <Wire.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <AccelStepper.h>
#include <U8g2lib.h>
#include <EEPROM.h>

/* ===================== PINS ===================== */
#define M1_STEP 26
#define M1_DIR 27
#define M1_EN 14

#define M2_STEP 12
#define M2_DIR 13
#define M2_EN 15

#define ENC_CLK 32
#define ENC_DT 33
#define ENC_SW 25

// EEPROM addresses
#define EEPROM_SIZE 64
#define ADDR_M1_START 0
#define ADDR_M1_END 4
#define ADDR_M1_SPEED 8
#define ADDR_M2_START 12
#define ADDR_M2_END 16
#define ADDR_M2_SPEED 20
#define ADDR_CYCLES 24
#define ADDR_RETURN 28

/* ===================== STEPPERS ===================== */
AccelStepper step1(AccelStepper::DRIVER, M1_STEP, M1_DIR);
AccelStepper step2(AccelStepper::DRIVER, M2_STEP, M2_DIR);

/* ===================== OLED ===================== */
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

/* ===================== MENU ===================== */
enum MenuItem {
  MI_RUN,
  MI_M1_START,
  MI_M1_END,
  MI_M1_SPEED,
  MI_M2_START,
  MI_M2_END,
  MI_M2_SPEED,
  MI_TRACK_M1,
  MI_TRACK_M2,
  MI_TRACK_BOTH,
  MI_RETURN,
  MI_CYCLES,
  MI_HOME,
  MI_COUNT
};

const char* menuItems[MI_COUNT] = {
  "RUN","M1 START","M1 END","M1 SPEED",
  "M2 START","M2 END","M2 SPEED",
  "TRACK M1","TRACK M2","TRACK BOTH",
  "RETURN","CYCLES","HOME"
};

int menuIndex = 0;
bool editMode = false;
int scrollOffset = 0;
const int OLED_ROWS = 5;
#include <Wire.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <AccelStepper.h>
#include <U8g2lib.h>
#include <EEPROM.h>

/* ===================== PINS ===================== */
#define M1_STEP 26
#define M1_DIR 27
#define M1_EN 14

#define M2_STEP 12
#define M2_DIR 13
#define M2_EN 15

#define ENC_CLK 32
#define ENC_DT 33
#define ENC_SW 25

// EEPROM addresses
#define EEPROM_SIZE 64
#define ADDR_M1_START 0
#define ADDR_M1_END 4
#define ADDR_M1_SPEED 8
#define ADDR_M2_START 12
#define ADDR_M2_END 16
#define ADDR_M2_SPEED 20
#define ADDR_CYCLES 24
#define ADDR_RETURN 28

/* ===================== STEPPERS ===================== */
AccelStepper step1(AccelStepper::DRIVER, M1_STEP, M1_DIR);
AccelStepper step2(AccelStepper::DRIVER, M2_STEP, M2_DIR);

/* ===================== OLED ===================== */
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

/* ===================== MENU ===================== */
enum MenuItem {
  MI_RUN,
  MI_M1_START,
  MI_M1_END,
  MI_M1_SPEED,
  MI_M2_START,
  MI_M2_END,
  MI_M2_SPEED,
  MI_TRACK_M1,
  MI_TRACK_M2,
  MI_TRACK_BOTH,
  MI_RETURN,
  MI_CYCLES,
  MI_HOME,
  MI_COUNT
};

const char* menuItems[MI_COUNT] = {
  "RUN","M1 START","M1 END","M1 SPEED",
  "M2 START","M2 END","M2 SPEED",
  "TRACK M1","TRACK M2","TRACK BOTH",
  "RETURN","CYCLES","HOME"
};

int menuIndex = 0;
bool editMode = false;
int scrollOffset = 0;
const int OLED_ROWS = 5;
/* ===================== STATE ===================== */
bool running = false;
bool paused = false;
bool returnEnabled = true;

long m1Start=0, m1End=2000, m1Speed=2000;
long m2Start=0, m2End=2000, m2Speed=2000;
int cycles = 0;
int currentCycle = 0;
bool goingToEnd = true;

/* ===================== TRACKING ===================== */
bool trackM1Menu = false;
bool trackM2Menu = false;
float trackSpeed = 0;
const float TRACK_MAX_SPEED = 800;

/* ===================== BLE JOG SMOOTHING ===================== */
float targetSpeedM1=0, targetSpeedM2=0;
float currentSpeedM1=0, currentSpeedM2=0;
const float SPEED_STEP=20;

/* ===================== HOMING ===================== */
bool homingActive = false;

/* ===================== ENCODER ===================== */
int lastCLK;
int lastButtonState=HIGH;
int buttonState=HIGH;
unsigned long lastDebounce=0;
const unsigned long debounceDelay=50;
unsigned long lastDraw=0;

/* ===================== BLE ===================== */
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcd1234-1234-1234-1234-abcdef123456"
BLECharacteristic* pCharacteristic;
bool bleConnected=false;

/* ===================== PROTOTYPES ===================== */
void parseBLE(String cmd);
void handleJogSlider(String cmd);
void handleEncoder();
void handleButton();
void onClick();
void editValue(int dir);
void drawMenu();
void startRun();
void stopRun();
void runSequence();
void enableMotors();
void disableMotors();
void startHoming();
void saveSettings();
void loadSettings();

/* ===================== BLE CALLBACK ===================== */
class MyCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    String cmd = pChar->getValue().c_str();
    cmd.trim();
    Serial.print("BLE RX: "); Serial.println(cmd);
    parseBLE(cmd);
  }
};
/* ===================== SETUP ===================== */
void setup() {
  Serial.begin(115200);
  delay(1000);

  pinMode(M1_EN, OUTPUT); pinMode(M2_EN, OUTPUT);
  digitalWrite(M1_EN,HIGH); digitalWrite(M2_EN,HIGH);

  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);

  loadSettings();  // Load EEPROM settings

  step1.setMaxSpeed(m1Speed); step1.setAcceleration(1000);
  step2.setMaxSpeed(m2Speed); step2.setAcceleration(1000);

  lastCLK = digitalRead(ENC_CLK);

  u8g2.begin();
  drawMenu();

  // BLE setup
  BLEDevice::init("CameraSlider");
  BLEServer* server = BLEDevice::createServer();
  BLEService* service = server->createService(SERVICE_UUID);
  pCharacteristic = service->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_WRITE
  );
  pCharacteristic->setCallbacks(new MyCharacteristicCallbacks());
  service->start();
  BLEDevice::startAdvertising();
  
  Serial.println("Setup done");
}

/* ===================== LOOP ===================== */
void loop() {
  handleEncoder();
  handleButton();

  // Smooth BLE jog ramp
  if(targetSpeedM1 != 0 || targetSpeedM2 != 0){
    if(currentSpeedM1 < targetSpeedM1) currentSpeedM1 = min(currentSpeedM1 + SPEED_STEP, targetSpeedM1);
    else if(currentSpeedM1 > targetSpeedM1) currentSpeedM1 = max(currentSpeedM1 - SPEED_STEP, targetSpeedM1);

    if(currentSpeedM2 < targetSpeedM2) currentSpeedM2 = min(currentSpeedM2 + SPEED_STEP, targetSpeedM2);
    else if(currentSpeedM2 > targetSpeedM2) currentSpeedM2 = max(currentSpeedM2 - SPEED_STEP, targetSpeedM2);

    step1.setSpeed(currentSpeedM1); step1.runSpeed();
    step2.setSpeed(currentSpeedM2); step2.runSpeed();
  }
  // Menu tracking mode
  else if(trackM1Menu || trackM2Menu){
    step1.setSpeed(trackM1Menu ? trackSpeed : 0);
    step2.setSpeed(trackM2Menu ? trackSpeed : 0);
    step1.runSpeed();
    step2.runSpeed();
  }

  if(running && !paused){
    runSequence();
    step1.run();
    step2.run();
  }

  // HOMING movement
  if(homingActive){
    bool moving1 = step1.run();
    bool moving2 = step2.run();
    if(!moving1 && !moving2){
      homingActive = false;
      step1.setCurrentPosition(0);
      step2.setCurrentPosition(0);
      disableMotors();
      Serial.println("HOMING complete");
      drawMenu();
    }
  }
}
/* ===================== ENCODER ===================== */
void handleEncoder() {
  int clk=digitalRead(ENC_CLK);
  if(clk != lastCLK){
    int dir=(digitalRead(ENC_DT)!=clk)?1:-1;

    if(trackM1Menu || trackM2Menu){
      trackSpeed += dir*40;
      trackSpeed = constrain(trackSpeed,-TRACK_MAX_SPEED,TRACK_MAX_SPEED);
    }
    else if(editMode) editValue(dir);
    else menuIndex=constrain(menuIndex+dir,0,MI_COUNT-1);

    if(millis()-lastDraw>30){
      drawMenu(); lastDraw=millis();
    }

    lastCLK = clk;
  }
}

/* ===================== BUTTON ===================== */
void handleButton(){
  int reading=digitalRead(ENC_SW);
  if(reading != lastButtonState) lastDebounce=millis();
  if((millis()-lastDebounce)>debounceDelay){
    if(reading != buttonState){
      buttonState=reading;
      if(buttonState==LOW) onClick();
    }
  }
  lastButtonState=reading;
}

/* ===================== CLICK ===================== */
void onClick(){
  if(trackM1Menu || trackM2Menu){
    trackM1Menu=trackM2Menu=false;
    trackSpeed=0;
    drawMenu(); return;
  }

  if(editMode){
    editMode=false; drawMenu(); return;
  }

  switch(menuIndex){
    case MI_RUN: if(!running) startRun(); else paused=!paused; break;
    case MI_M1_START: case MI_M1_END: case MI_M1_SPEED:
    case MI_M2_START: case MI_M2_END: case MI_M2_SPEED: editMode=true; break;
    case MI_TRACK_M1: trackM1Menu=true; trackM2Menu=false; break;
    case MI_TRACK_M2: trackM1Menu=false; trackM2Menu=true; break;
    case MI_TRACK_BOTH: trackM1Menu=trackM2Menu=true; break;
    case MI_RETURN: returnEnabled=!returnEnabled; break;
    case MI_CYCLES: cycles=(cycles+1)%6; break;
    case MI_HOME: startHoming(); break;
  }

  drawMenu();
}

/* ===================== EDIT VALUES ===================== */
void editValue(int dir){
  int step=10;
  switch(menuIndex){
    case MI_M1_START: m1Start+=dir*step; break;
    case MI_M1_END:   m1End+=dir*step; break;
    case MI_M1_SPEED: m1Speed+=dir*step; step1.setMaxSpeed(m1Speed); break;
    case MI_M2_START: m2Start+=dir*step; break;
    case MI_M2_END:   m2End+=dir*step; break;
    case MI_M2_SPEED: m2Speed+=dir*step; step2.setMaxSpeed(m2Speed); break;
  }
  saveSettings();
}

/* ===================== EEPROM FUNCTIONS ===================== */
void saveSettings() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.put(ADDR_M1_START, m1Start);
  EEPROM.put(ADDR_M1_END, m1End);
  EEPROM.put(ADDR_M1_SPEED, m1Speed);
  EEPROM.put(ADDR_M2_START, m2Start);
  EEPROM.put(ADDR_M2_END, m2End);
  EEPROM.put(ADDR_M2_SPEED, m2Speed);
  EEPROM.put(ADDR_CYCLES, cycles);
  EEPROM.put(ADDR_RETURN, returnEnabled);
  EEPROM.commit();
  EEPROM.end();
}

void loadSettings() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.get(ADDR_M1_START, m1Start);
  EEPROM.get(ADDR_M1_END, m1End);
  EEPROM.get(ADDR_M1_SPEED, m1Speed);
  EEPROM.get(ADDR_M2_START, m2Start);
  EEPROM.get(ADDR_M2_END, m2End);
  EEPROM.get(ADDR_M2_SPEED, m2Speed);
  EEPROM.get(ADDR_CYCLES, cycles);
  EEPROM.get(ADDR_RETURN, returnEnabled);
  EEPROM.end();
}
