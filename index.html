#include <Wire.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <AccelStepper.h>
#include <U8g2lib.h>
#include <EEPROM.h>

/* ===================== PINS ===================== */
#define M1_STEP 26
#define M1_DIR 27
#define M1_EN 14

#define M2_STEP 12
#define M2_DIR 13
#define M2_EN 15

#define ENC_CLK 32
#define ENC_DT 33
#define ENC_SW 25

// EEPROM addresses
#define EEPROM_SIZE 64
#define ADDR_M1_START 0
#define ADDR_M1_END 4
#define ADDR_M1_SPEED 8
#define ADDR_M2_START 12
#define ADDR_M2_END 16
#define ADDR_M2_SPEED 20
#define ADDR_CYCLES 24
#define ADDR_RETURN 28

/* ===================== STEPPERS ===================== */
AccelStepper step1(AccelStepper::DRIVER, M1_STEP, M1_DIR);
AccelStepper step2(AccelStepper::DRIVER, M2_STEP, M2_DIR);

/* ===================== OLED ===================== */
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0);

/* ===================== MENU ===================== */
enum MenuItem {
  MI_RUN,
  MI_M1_START,
  MI_M1_END,
  MI_M1_SPEED,
  MI_M2_START,
  MI_M2_END,
  MI_M2_SPEED,
  MI_TRACK_M1,
  MI_TRACK_M2,
  MI_TRACK_BOTH,
  MI_RETURN,
  MI_CYCLES,
  MI_HOME,
  MI_COUNT
};

const char* menuItems[MI_COUNT] = {
"RUN","M1 START","M1 END","M1 SPEED",
  "M2 START","M2 END","M2 SPEED",
  "TRACK M1","TRACK M2","TRACK BOTH",
  "RETURN","CYCLES","HOME"
};

int menuIndex = 0;
bool editMode = false;
int scrollOffset = 0;
const int OLED_ROWS = 5;

/* ===================== STATE ===================== */
bool running = false;
bool paused = false;
bool returnEnabled = true;
bool jogActive = false;
int jogSpeed = 300;
long m1Start = -2000, m1End = 2000, m1Speed = 2000;
long m2Start = -2000, m2End = 2000, m2Speed = 2000;
int cycles = 0;
int currentCycle = 0;
bool goingToEnd = true;

/* ===================== TRACKING ===================== */
bool trackM1Menu = false;
bool trackM2Menu = false;
float trackSpeed = 0;
const float TRACK_MAX_SPEED = 800;

/* ===================== BLE JOG SMOOTHING ===================== */
float targetSpeedM1 = 0, targetSpeedM2 = 0;
float currentSpeedM1 = 0, currentSpeedM2 = 0;
const float SPEED_STEP = 20;

/* ===================== HOMING ===================== */
bool homingActive = false;

/* ===================== ENCODER ===================== */
int lastCLK;
int lastButtonState = HIGH;
int buttonState = HIGH;
unsigned long lastDebounce = 0;
const unsigned long debounceDelay = 50;
unsigned long lastDraw = 0;

/* ===================== BLE ===================== */
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcd1234-1234-1234-1234-abcdef123456"
BLECharacteristic* pCharacteristic;
bool bleConnected = false;
/* ===================== PROTOTYPES ===================== */
void parseBLE(String cmd);
void handleJogSlider(String cmd);
void handleEncoder();
void handleButton();
void onClick();
void editValue(int dir);
void drawMenu();
void startRun();
void stopRun();
void runSequence();
void enableMotors();
void disableMotors();
void startHoming();
void saveSettings();
void loadSettings();

/* ===================== BLE SERVER CALLBACKS ===================== */
class MyServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) override {
    bleConnected = true;
    Serial.println("BLE Connected");
  }
  
  void onDisconnect(BLEServer* pServer) override {
    bleConnected = false;
    Serial.println("BLE Disconnected");
    BLEDevice::startAdvertising();
  }
};

/* ===================== BLE CALLBACK ===================== */
class MyCharacteristicCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pChar) override {
    String cmd = pChar->getValue().c_str();
    cmd.trim();
    Serial.print("BLE RX: "); Serial.println(cmd);
    parseBLE(cmd);
  }
};

/* ===================== SETUP ===================== */
void setup() {
  Serial.begin(115200);
  delay(1000);

  // Initialize EEPROM
  EEPROM.begin(EEPROM_SIZE);
  loadSettings();

  pinMode(M1_EN, OUTPUT); pinMode(M2_EN, OUTPUT);
  digitalWrite(M1_EN, HIGH); digitalWrite(M2_EN, HIGH);

  pinMode(ENC_CLK, INPUT_PULLUP);
  pinMode(ENC_DT, INPUT_PULLUP);
  pinMode(ENC_SW, INPUT_PULLUP);

  // AMENDMENT 1: Slower acceleration for smoother starts/stops
  step1.setMaxSpeed(m1Speed); 
  step1.setAcceleration(400);  // Reduced from 1000
  step2.setMaxSpeed(m2Speed); 
  step2.setAcceleration(400);  // Reduced from 1000

  lastCLK = digitalRead(ENC_CLK);

  u8g2.begin();
  drawMenu();

  // BLE setup
  BLEDevice::init("CameraSlider");
  BLEServer* server = BLEDevice::createServer();
  server->setCallbacks(new MyServerCallbacks());
  BLEService* service = server->createService(SERVICE_UUID);
  pCharacteristic = service->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_WRITE
  );
  pCharacteristic->setCallbacks(new MyCharacteristicCallbacks());
  service->start();
  BLEDevice::startAdvertising();
  
  Serial.println("Setup done");
}

/* ===================== LOOP ===================== */
void loop() {
  handleEncoder();
  handleButton();

  // AMENDMENT 2: Enhanced jog control with proper axis selection
  if(jogActive || targetSpeedM1 != 0 || targetSpeedM2 != 0) {
    jogActive = (targetSpeedM1 != 0 || targetSpeedM2 != 0);
    
    // Smooth speed ramping
    if(currentSpeedM1 < targetSpeedM1) currentSpeedM1 = min(currentSpeedM1 + SPEED_STEP, targetSpeedM1);
    else if(currentSpeedM1 > targetSpeedM1) currentSpeedM1 = max(currentSpeedM1 - SPEED_STEP, targetSpeedM1);

    if(currentSpeedM2 < targetSpeedM2) currentSpeedM2 = min(currentSpeedM2 + SPEED_STEP, targetSpeedM2);
    else if(currentSpeedM2 > targetSpeedM2) currentSpeedM2 = max(currentSpeedM2 - SPEED_STEP, targetSpeedM2);

    step1.setSpeed(currentSpeedM1); step1.runSpeed();
    step2.setSpeed(currentSpeedM2); step2.runSpeed();
  }
  // Menu tracking mode
  else if(trackM1Menu || trackM2Menu) {
    step1.setSpeed(trackM1Menu ? trackSpeed : 0);
    step2.setSpeed(trackM2Menu ? trackSpeed : 0);
    step1.runSpeed();
    step2.runSpeed();
  }

  // Run sequence with amended acceleration
  if(running && !paused) {
    runSequence();
    step1.run();
    step2.run();
  }

  // AMENDMENT 3: Modified homing to set position to 0 (center point)
  if(homingActive) {
    bool moving1 = step1.run();
    bool moving2 = step2.run();
    if(!moving1 && !moving2) {
      homingActive = false;
      // Set current position as 0 (home/center point)
      step1.setCurrentPosition(0);
      step2.setCurrentPosition(0);
      disableMotors();
      Serial.println("HOMING complete - Position set to 0");
      drawMenu();
    }
  }
}
/* ===================== BLE PARSER ===================== */
void parseBLE(String cmd){
  if(cmd.startsWith("M1S:")) m1Start=cmd.substring(4).toInt();
  else if(cmd.startsWith("M1E:")) m1End=cmd.substring(4).toInt();
  else if(cmd.startsWith("M2S:")) m2Start=cmd.substring(4).toInt();
  else if(cmd.startsWith("M2E:")) m2End=cmd.substring(4).toInt();
  else if(cmd.startsWith("M1SPD:")) { m1Speed=cmd.substring(6).toInt(); step1.setMaxSpeed(m1Speed); }
  else if(cmd.startsWith("M2SPD:")) { m2Speed=cmd.substring(6).toInt(); step2.setMaxSpeed(m2Speed); }
  else if(cmd.startsWith("CYCLES:")) cycles=cmd.substring(7).toInt();
  else if(cmd.startsWith("JOGSPEED:")) jogSpeed=cmd.substring(9).toInt();
  else if(cmd.startsWith("RETURN:")) returnEnabled=cmd.substring(7).toInt();
  else if(cmd.startsWith("JOGSLIDER:")) handleJogSlider(cmd);
  else if(cmd=="RUN") startRun();
  else if(cmd=="STOP") stopRun();
  else if(cmd=="HOME") startHoming();
  saveSettings();
}

/* ===================== ENHANCED BLE JOG WITH AXIS SELECTION ===================== */
void handleJogSlider(String cmd){
  // Parse: "JOGSLIDER:AXIS:VALUE"
  int p1 = cmd.indexOf(':', 10);
  int p2 = cmd.lastIndexOf(':');
  
  if(p1 == -1 || p2 == -1 || p1 == p2) return;
  
  String axis = cmd.substring(10, p1);
  int value = cmd.substring(p2 + 1).toInt();
  
  // Calculate speed based on percentage (-100 to +100)
  float ratio = value / 100.0;
  float speed = ratio * jogSpeed;  // Use jogSpeed setting
  
  // Apply to selected axis
  if(axis == "M1") {
    targetSpeedM1 = speed;
    targetSpeedM2 = 0;  // Stop other motor
  }
  else if(axis == "M2") {
    targetSpeedM1 = 0;  // Stop other motor
    targetSpeedM2 = speed;
  }
  else if(axis == "BOTH") {
    targetSpeedM1 = speed;
    targetSpeedM2 = speed;
  }
  
  // Stop all if value is 0
  if(value == 0) {
    targetSpeedM1 = 0;
    targetSpeedM2 = 0;
  }
  
  // Enable motors for jogging
  if(speed != 0) {
    enableMotors();
  }
  
  Serial.print("Jog: "); Serial.print(axis); 
  Serial.print(" = "); Serial.println(speed);
}

/* ===================== ENHANCED RUN SEQUENCE ===================== */
void runSequence(){
  // AMENDMENT 1: Check if both motors have stopped moving
  if(step1.isRunning() || step2.isRunning()) return;
  
  // Small delay at end points to prevent immediate direction change
  static unsigned long endReachedTime = 0;
  static bool waitingAtEnd = false;
  
  if(!waitingAtEnd) {
    waitingAtEnd = true;
    endReachedTime = millis();
    return;  // Start waiting period
  }
  
  // AMENDMENT 1: Wait 100ms at each end to eliminate pause/jerkiness
  if(millis() - endReachedTime < 100) return;
  
  waitingAtEnd = false;  // End waiting period
  
  if(returnEnabled){
    if(goingToEnd){
      step1.moveTo(m1Start); 
      step2.moveTo(m2Start);
      goingToEnd = false; 
      return;
    } else {
      goingToEnd = true;
      if(cycles != 0 && ++currentCycle >= cycles){ 
        stopRun(); 
        return; 
      }
      step1.moveTo(m1End); 
      step2.moveTo(m2End);
    }
  } else {
    if(cycles != 0 && ++currentCycle >= cycles){ 
      stopRun(); 
      return; 
    }
    step1.moveTo(m1End); 
    step2.moveTo(m2End);
  }
}

/* ===================== MOTORS & ENHANCED HOMING ===================== */
void enableMotors(){
  digitalWrite(M1_EN, LOW); 
  digitalWrite(M2_EN, LOW);
}

void disableMotors(){
  digitalWrite(M1_EN, HIGH); 
  digitalWrite(M2_EN, HIGH);
}

// AMENDMENT 3: Enhanced homing that sets current position as 0 (center)
void startHoming(){
  running = false; 
  paused = false;
  enableMotors();
  
  step1.setMaxSpeed(1000); 
  step2.setMaxSpeed(1000);
  step1.setAcceleration(800);  // Slower for smoother homing
  step2.setAcceleration(800);
  
  // Move to position 0 (will be set as new home/center point)
  step1.moveTo(0); 
  step2.moveTo(0);
  homingActive = true;
  Serial.println("HOMING started - Moving to center position");
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Slider Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            color: #333;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .status {
            font-size: 16px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }

        .connect-btn {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 10px 0;
            transition: transform 0.2s;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
        }

        /* AMENDMENT 2: Enhanced jog control section */
        .jog-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .jog-section h3 {
            margin-bottom: 15px;
            color: #495057;
        }

        /* AMENDMENT 2: Motor selection buttons */
        .motor-select {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .motor-btn {
            background: #e9ecef;
            border: 2px solid #ced4da;
            color: #495057;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .motor-btn.active {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border-color: #28a745;
        }

        /* AMENDMENT 2: Enhanced slider styling - kept large size */
        .slider-container {
            margin: 20px 0;
            position: relative;
        }

        .jog-slider {
            width: 100%;
            height: 50px;
            background: linear-gradient(to right, #dc3545, #ffc107, #28a745);
            border-radius: 25px;
            outline: none;
            appearance: none;
            cursor: pointer;
        }

        .jog-slider::-webkit-slider-thumb {
            appearance: none;
            width: 60px;
            height: 60px;
            background: white;
            border-radius: 50%;
            border: 4px solid #007bff;
            cursor: grab;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .jog-slider::-webkit-slider-thumb:active {
            cursor: grabbing;
            transform: scale(1.1);
        }

        .slider-value {
            font-size: 18px;
            font-weight: bold;
            color: #495057;
            margin-top: 10px;
        }
.control-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #495057;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 2px solid #e9ecef;
        }

        .input-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }

        .input-group label {
            font-weight: 600;
            color: #495057;
            min-width: 100px;
        }

        .input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ced4da;
            border-radius: 8px;
            font-size: 16px;
        }

        .btn {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 5px;
            transition: all 0.2s;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn.stop {
            background: linear-gradient(45deg, #dc3545, #fd7e14);
        }

        .btn.home {
            background: linear-gradient(45deg, #6f42c1, #e83e8c);
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            .title {
                font-size: 24px;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-group label {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">Camera Slider Control</h1>
            <div class="status disconnected" id="status">Disconnected</div>
            <button class="connect-btn" id="connectBtn">Connect to Slider</button>
        </div>

        <!-- AMENDMENT 2: Enhanced Jog Control Section -->
        <div class="jog-section">
            <h3>Manual Jog Control</h3>
            
            <!-- Motor Selection Buttons -->
            <div class="motor-select">
                <button class="motor-btn active" data-motor="M1">Motor 1</button>
                <button class="motor-btn" data-motor="M2">Motor 2</button>
                <button class="motor-btn" data-motor="BOTH">Both</button>
            </div>
            
            <!-- Large Jog Slider (returns to center) -->
            <div class="slider-container">
                <input type="range" class="jog-slider" id="jogSlider" 
                       min="-100" max="100" value="0" step="1">
                <div class="slider-value" id="sliderValue">0%</div>
            </div>
        </div>

        <div class="control-section">
            <h3 class="section-title">Motor 1 Settings</h3>
            <div class="input-group">
                <label>Start:</label>
                <input type="number" id="m1Start" value="-2000">
            </div>
            <div class="input-group">
                <label>End:</label>
                <input type="number" id="m1End" value="2000">
            </div>
            <div class="input-group">
                <label>Speed:</label>
                <input type="number" id="m1Speed" value="2000">
            </div>
        </div>

        <div class="control-section">
            <h3 class="section-title">Motor 2 Settings</h3>
            <div class="input-group">
                <label>Start:</label>
                <input type="number" id="m2Start" value="-2000">
            </div>
            <div class="input-group">
                <label>End:</label>
                <input type="number" id="m2End" value="2000">
            </div>
            <div class="input-group">
                <label>Speed:</label>
                <input type="number" id="m2Speed" value="2000">
            </div>
        </div>

        <div class="control-section">
            <h3 class="section-title">Sequence Settings</h3>
            <div class="input-group">
                <label>Cycles:</label>
                <input type="number" id="cycles" value="0" min="0">
            </div>
            <div class="input-group">
                <label>Return:</label>
                <input type="checkbox" id="returnEnabled" checked>
            </div>
        </div>

        <div class="control-section">
            <button class="btn" id="runBtn">RUN</button>
            <button class="btn stop" id="stopBtn">STOP</button>
            <button class="btn home" id="homeBtn">HOME</button>
        </div>
    </div>
<script>
        let device;
        let characteristic;
        let selectedMotor = 'M1';  // Default motor selection
        
        // DOM elements
        const status = document.getElementById('status');
        const connectBtn = document.getElementById('connectBtn');
        const jogSlider = document.getElementById('jogSlider');
        const sliderValue = document.getElementById('sliderValue');
        const motorBtns = document.querySelectorAll('.motor-btn');
        
        // Input elements
        const inputs = {
            m1Start: document.getElementById('m1Start'),
            m1End: document.getElementById('m1End'),
            m1Speed: document.getElementById('m1Speed'),
            m2Start: document.getElementById('m2Start'),
            m2End: document.getElementById('m2End'),
            m2Speed: document.getElementById('m2Speed'),
            cycles: document.getElementById('cycles'),
            returnEnabled: document.getElementById('returnEnabled')
        };
        
        // Control buttons
        const runBtn = document.getElementById('runBtn');
        const stopBtn = document.getElementById('stopBtn');
        const homeBtn = document.getElementById('homeBtn');

        /* ===================== BLE CONNECTION ===================== */
        async function connectToDevice() {
            try {
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ name: 'CameraSlider' }],
                    optionalServices: ['12345678-1234-1234-1234-1234567890ab']
                });

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService('12345678-1234-1234-1234-1234567890ab');
                characteristic = await service.getCharacteristic('abcd1234-1234-1234-1234-abcdef123456');

                status.textContent = 'Connected';
                status.className = 'status connected';
                connectBtn.textContent = 'Connected';
                connectBtn.disabled = true;

                // Handle disconnection
                device.addEventListener('gattserverdisconnected', onDisconnected);

            } catch (error) {
                console.error('Connection failed:', error);
                status.textContent = 'Connection failed';
                status.className = 'status disconnected';
            }
        }

        function onDisconnected() {
            status.textContent = 'Disconnected';
            status.className = 'status disconnected';
            connectBtn.textContent = 'Connect to Slider';
            connectBtn.disabled = false;
        }

        /* ===================== BLE SEND ===================== */
        async function sendBLE(command) {
            if (!characteristic) return;
            try {
                await characteristic.writeValue(new TextEncoder().encode(command));
                console.log('Sent:', command);
            } catch (error) {
                console.error('Send failed:', error);
            }
        }

        /* ===================== MOTOR SELECTION ===================== */
        motorBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all buttons
                motorBtns.forEach(b => b.classList.remove('active'));
                
                // Add active class to clicked button
                btn.classList.add('active');
                
                // Update selected motor
                selectedMotor = btn.dataset.motor;
                
                // Reset slider to center when switching motors
                jogSlider.value = 0;
                sliderValue.textContent = '0%';
                sendBLE(`JOGSLIDER:${selectedMotor}:0`);
            });
        });

        /* ===================== ENHANCED JOG SLIDER ===================== */
        let isSliding = false;
        let centerReturnTimeout;

        // Mouse/touch events for slider
        jogSlider.addEventListener('mousedown', () => isSliding = true);
        jogSlider.addEventListener('mouseup', handleSliderRelease);
        jogSlider.addEventListener('touchstart', () => isSliding = true);
        jogSlider.addEventListener('touchend', handleSliderRelease);

        // Slider input (while dragging)
        jogSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            sliderValue.textContent = `${value}%`;
            
            // Only send while actively sliding
            if (isSliding) {
                clearTimeout(centerReturnTimeout);
                sendBLE(`JOGSLIDER:${selectedMotor}:${value}`);
            }
        });

        // Handle slider release - return to center
        function handleSliderRelease() {
            isSliding = false;
            
            // Immediately stop motors
            sendBLE(`JOGSLIDER:${selectedMotor}:0`);
            
            // Animate return to center
            centerReturnTimeout = setTimeout(() => {
                jogSlider.value = 0;
                sliderValue.textContent = '0%';
            }, 100);
        }

        /* ===================== INPUT HANDLERS ===================== */
        // Send settings when inputs change
        Object.entries(inputs).forEach(([key, input]) => {
            input.addEventListener('change', () => {
                const value = input.type === 'checkbox' ? (input.checked ? 1 : 0) : input.value;
                
                switch(key) {
                    case 'm1Start': sendBLE(`M1S:${value}`); break;
                    case 'm1End': sendBLE(`M1E:${value}`); break;
                    case 'm1Speed': sendBLE(`M1SPD:${value}`); break;
                    case 'm2Start': sendBLE(`M2S:${value}`); break;
                    case 'm2End': sendBLE(`M2E:${value}`); break;
                    case 'm2Speed': sendBLE(`M2SPD:${value}`); break;
                    case 'cycles': sendBLE(`CYCLES:${value}`); break;
                    case 'returnEnabled': sendBLE(`RETURN:${value}`); break;
                }
            });
        });

        /* ===================== CONTROL BUTTONS ===================== */
        runBtn.addEventListener('click', () => sendBLE('RUN'));
        stopBtn.addEventListener('click', () => {
            sendBLE('STOP');
            // Also stop any active jogging
            jogSlider.value = 0;
            sliderValue.textContent = '0%';
            sendBLE(`JOGSLIDER:${selectedMotor}:0`);
        });
        homeBtn.addEventListener('click', () => sendBLE('HOME'));

        /* ===================== EVENT LISTENERS ===================== */
        connectBtn.addEventListener('click', connectToDevice);

        // Prevent slider from jumping when page scrolls
        jogSlider.addEventListener('touchmove', (e) => {
            if (isSliding) e.preventDefault();
        }, { passive: false });

        // Initialize motor selection
        document.querySelector('.motor-btn[data-motor="M1"]').classList.add('active');
    </script>
</body>
</html>















